import sys
import serial
import time
import threading
import json
import random
from fractions import gcd
from WebSocketServer import WebSocket, SimpleWebSocketServer, SimpleSSLWebSocketServer

from generated.ODriveAutoGenerated import ODriveAutoGenerated
from generated.MappingAutoGenerated import variable_map

from Motor import Motor

DEBUG = False

websocket_clients = []
websocketServer = None
odrive = None

class Monitoring():
    def __init__(self,type,nr,frequency):
        self.type = type
        self.nr = nr
        self.slot = 999 # slot gets auto assigned by _reorder_monitoring
        self.frequency = frequency
       

class WebsocketServer():

    def __init__(self,host ,port):
        global callback
        self.host = host
        self.port = port
        t = threading.Thread(target=self.thread)
        t.daemon = True
        t.start()
        self.running = True

    def thread(self):
        print(("Starting ODrive websocket on %s:%s" % (self.host,self.port)))
        self.server = SimpleWebSocketServer(self.host,self.port, self.MsgServer)
        self.server.serveforever()
        self.running = False

    def sendToClients(self,msg):
        for c in websocket_clients:
            c.sendMessage(msg)
            
    def send_chartdata(self,chartdata):
        self.sendToClients(json.dumps({"chart": chartdata} ));
                      
    class MsgServer(WebSocket):
        def handleMessage(self):
            # TODO : don't relay on global odrive variable..
            try:
                data = json.loads(self.data.decode("utf-8") )
                print data
                results = []
                if data.keys()[0] == "getAll":
                    for key in variable_map.keys():
                        type,nr = variable_map[key].type,variable_map[key].nr
                        value = odrive._get(type,nr)
                        results.append([type, nr, value] )
                    self.sendMessage(json.dumps({"values": results} ));
                    
                if data.keys()[0] == "get":
                    value = odrive._get(data["get"]["type"],data["get"]["nr"])
                    results.append([type, nr, value] )
                    self.sendMessage(json.dumps({"values": results}))
                    
                if data.keys()[0] == "set":
                    odrive._set(data["set"]["type"],data["set"]["nr"],data["set"]["value"])
                                        
                if data.keys()[0] == "monitor":
                    odrive._monitor(data["monitor"]["type"],data["monitor"]["nr"],data["monitor"]["frequency"])
                                        
            except Exception,e:
                print e
                
        def handleConnected(self):
            print((self.address, 'connected'))
            self.sendMessage(json.dumps({"mappings": [{"name":variable_map[k].name,"type":variable_map[k].type,"nr":variable_map[k].nr,"access":variable_map[k].access,"min":variable_map[k].min,"max":variable_map[k].max} for k in variable_map.keys() ]}))
            websocket_clients.append(self)

        def handleClose(self):
            print((self.address, 'closed'))
            websocket_clients.remove(self)
  
 
            
class ODrive(ODriveAutoGenerated):
    def __init__(self,tty):	    
        if tty == "none":
            self._serial = None
        else:
            self._serial = serial.Serial(tty)
        self.motors = [
            Motor(0,self),
            Motor(1,self),
        ]

        # Monitoring stuff
        self.active_monitorings = []        
        self.base_delay = 1 # in seconds
        self.multipliers_highest_indexes = {} # how many array values do we have to read at what cycle of the monitoring loop to match the user given monitoring frequency
        self.monitoring_callbacks = [] # these external functions are called by the monitoring thread on new data. 
        t = threading.Thread(target=self.monitoring_thread)
        t.daemon = True
        t.start()
        
        
    def monitoring_thread(self):        
        cnt=0 # loop step count
        while True:
            s = time.time()
            for x in sorted(self.multipliers_highest_indexes.keys(),reverse=True):
                if cnt % x == 0:
                    index = self.multipliers_highest_indexes[x]
                    self._ttysend("o %s" % (index + 1))
                    r = self._ttyread()
                    
                    if self._serial == None:
                        p = [random.randint(0,100) for i in range(0,index+1)]
                    else:
                        p = r.split("\t")    
                    results = []
                    for i in range(0,index+1):
                        results.append(( self.active_monitorings[i].type , self.active_monitorings[i].nr , float(p[i])))
                    for callback in self.monitoring_callbacks:
                        callback(results)
                    break
            cnt += 1
            diff = time.time() - s
            sleeptime = self.base_delay-diff
            if sleeptime < 0.00001:
                sleeptime = 0.00001
                print "warning,can't reach base frequency"
            time.sleep(sleeptime)
            
    # order monitoring so most frequently used values are on start of monitoring slots
    def _reorder_monitoring(self):    
        if len(self.active_monitorings) == 0:
            self.base_delay = 1
            self.multipliers_highest_indexes = {} 
            return 
            
        self.active_monitorings.sort(key=lambda x: x.frequency, reverse=True)
        
        base_delay = reduce(gcd,[ int((1.0/m.frequency)*10000) for m in self.active_monitorings]) # in 1/10  ms, so base base freq is max 10khz
        base_frequency = 1.0 / (base_delay) * 10000.0
        self.base_delay = base_delay / 10000.0
        new_multipliers_highest_indexes = {}   
        for index in range(0,len(self.active_monitorings)):
            mon = self.active_monitorings[index]
            if mon.slot != index:
                mon.slot = index
                self._ttysend("m %s %s %s" % (mon.type,mon.nr,mon.slot))
                
            multiplier = int(base_frequency / self.active_monitorings[index].frequency)
            try:
                if new_multipliers_highest_indexes[multiplier] < index:
                    new_multipliers_highest_indexes[multiplier] = index
            except:
                new_multipliers_highest_indexes[multiplier] = index
                
        self.multipliers_highest_indexes = new_multipliers_highest_indexes

    # these functions are used by the auto generated code    
    
    def _get(self,type,nr):
        self._ttysend("g %s %s" % (type,nr))
        value = self._ttyread()
        return self._convert_get(type,value)

    def _set(self,type,nr,value):
        self._ttysend("s %s %s %s" % (type,nr,self._convert_set(type,value)))
    
    def _monitor(self,type,nr,frequency):
        self.active_monitorings = [m for m in self.active_monitorings if m.type!=type or m.nr!=nr]
        if frequency > 0:
            m = Monitoring(type,nr,frequency)
            self.active_monitorings.append(m)
        self._reorder_monitoring()

    def _convert_get(self,type,value):
        if type == 0:
            return float(value)	
        if type == 1:
            return int(value)
        if type == 2:
            return not bool(int(value))
            
    def _convert_set(self,type,value):
        if type == 0:
            return float(value)	
        if type == 1:
            return int(value)
        if type == 2:
            if bool(value) == True:
                return 0
            return 1
            
    # raw tty functions, lowest level
    
    def _ttysend(self,data):
        if DEBUG:
            print "sending '%s'" % data
        if self._serial != None:
            self._serial.write(data)	
        else:
            print "Serial dummy: %s" % data
        
    def _ttyread(self):
        if self._serial != None:
            r = self._serial.readline()
        else:
            r = 1
        if DEBUG:
            print "received '%s'" % r 
        return r

            
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print "Usage: "
        print "Odrive.py tty <ip:port>"
        print ""
        print "tty     : tty device, required"
        print "ip:port : optional, defaults to 127.0.0.1:12342"
        print ""
        exit(1)
        
    tty = sys.argv[1]
    try:
        ip = sys.argv[2].split(":")[0]
        port = int(sys.argv[2].split(":")[1])
    except:
        ip = "127.0.0.1"
        port = 12342
    
    websocketServer = WebsocketServer(ip,port)    
       
    odrive = ODrive(tty)	
    odrive.monitoring_callbacks.append(websocketServer.send_chartdata)

    from IPython import embed
    embed()
